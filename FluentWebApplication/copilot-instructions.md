## Copilot / AI agent instructions for FluentWebApplication

This project is a small ASP.NET Core Razor Pages sample that demonstrates FluentValidation, EF Core (generated models/context), Serilog, and a small ConsoleConfigurationLibrary for entity seeding. The goal of this file is to give an AI coding agent exactly the actionable context needed to make safe, useful changes.

Quick checklist for changes
- Keep Razor Pages behavior unchanged unless editing pages under `Pages/`.
- Preserve EF Core generated artifacts under `Data/` and `Models/` (they were produced by EF Core Power Tools).
- When changing DI, update `Program.cs` and check usages in `Pages/*` constructors.

Big picture
- App type: ASP.NET Core Razor Pages app (see `Program.cs`).
- Data layer: EF Core DbContext in `Data/Context.cs`, models in `Models/` — these files are auto-generated by EF Core Power Tools (do not change primary keys/names without also updating migrations or regeneration).
- Validation: FluentValidation is registered in `Program.cs`. Concrete validators (e.g., `PersonValidator`) live in `Models/` and are injected into Razor Page constructors (see `Pages/Create.cshtml.cs`).
- Logging: Serilog is configured in `Program.cs` to write to a dated LogFiles folder under the app base directory.
- Configuration: `ConsoleConfigurationLibrary` / `EntitySettings.Instance` is used to control runtime seeding (see `Data/Context.cs`).

Developer workflows (how to build, run, debug)
- Build: the project is a standard .NET project. Use the dotnet CLI from the repository root:

```powershell
dotnet build
dotnet run --project FluentWebApplication.csproj
```

- Debugging: run from Visual Studio or `dotnet run` and open the app in the browser. `Program.cs` sets up Razor Pages; breakpoints in `Pages/*.cshtml.cs`, `Models/*`, and `Data/Context.cs` are effective.
- EF Core / db: This repo contains EF Core generated code (no migrations checked in). If modifying the model shape, prefer regenerating via EF Core Power Tools or add migrations and update the database accordingly.

Project-specific conventions & patterns
- EF Core Power Tools generated files include the `<auto-generated>` header. Treat these as canonical and regenerate rather than hand-editing when schema changes are needed.
- Validators are simple `AbstractValidator<T>` classes placed in `Models/` (e.g., `PersonValidator`). The project registers validators via `builder.Services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly())` and enables automatic validation via `AddFluentValidationAutoValidation()` in `Program.cs`.
- DI pattern: Razor Pages receive services via constructor injection. When adding a service, update `Program.cs` and check pages for constructors that require the new service.
- Logging: Serilog writes to a LogFiles subfolder; avoid changing the sink configuration casually.

Integration points and external dependencies
- NuGet packages used (from project output):
  - FluentValidation.AspNetCore
  - Microsoft.EntityFrameworkCore.SqlServer
  - Serilog
  - ConsoleConfigurationLibrary (project uses `EntitySettings.Instance` for seeding behavior)
- Database connection string: `DefaultConnection` in `appsettings.json`/`appsettings.Development.json`. Changes to connection strings may be environment-specific.

Safe edits and examples
- To add a new validator: create `Models/MyEntityValidator.cs` deriving from `AbstractValidator<MyEntity>`. No further registration required because validators are picked up by assembly scanning.
- To add a service: register it in `Program.cs` (e.g., `builder.Services.AddScoped<IMySvc, MySvc>()`) and inject into Razor Page constructors.
- To seed data conditionally: prefer modifying `EntitySettings` (from ConsoleConfigurationLibrary) or use the `OnModelCreating` pattern already present in `Data/Context.cs`.

Files worth checking for context
- `Program.cs` — app startup, DI, logging, validators registration.
- `Data/Context.cs` — EF Core context, seeding behavior references `EntitySettings.Instance.CreateNew`.
- `Models/Person.cs`, `Models/PersonValidator.cs` — canonical example of model + validation pattern.
- `Pages/` — Razor Pages where DI and validation are used (e.g., `Create.cshtml.cs`).
- `readme.md` — short project notes and examples of how the author intended to wire FluentValidation.

What NOT to change without coordination
- Avoid manual edits to EF Core generated files in `Data/` and `Models/` unless you also update migrations or regenerate them.
- Don't remove Serilog configuration unless replacing it with an equivalent; tests and developers rely on its file sink.

If you make a behavior-changing change
- Run `dotnet build` and `dotnet run` and exercise the affected Razor pages (Create/Edit/List) locally.
- If DB schema changed, add EF Core migrations or regenerate code with Power Tools; document the steps in `readme.md`.

Questions for the repo owner
- Is there a preferred way to run the database locally (localdb/SQL Server instance name)? If so, add the connection string and `dotnet ef` steps to `readme.md`.
- Are EF Core migrations intentionally omitted because regeneration via Power Tools is the intended flow? If yes, specify the exact Power Tools commands/version.

End of instructions — please review and tell me any missing local dev steps or environment notes to include.

## Local DB, migrations, and EF Core Power Tools (concrete steps)

When changing the model shape you'll either add EF Core migrations or re-run EF Core Power Tools reverse-engineer. Pick one of the two workflows below and document which your team prefers.

- Recommended local dev DB (example connection string) — put this into `appsettings.Development.json` for local runs:

```json
"ConnectionStrings": {
  "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=FluentWebAppDb;Trusted_Connection=True;MultipleActiveResultSets=true"
}
```

- Using EF Core migrations (CLI quickstart):
  - Ensure `dotnet-ef` is available: `dotnet tool install --global dotnet-ef` (one-time).
  - Ensure `Microsoft.EntityFrameworkCore.Design` is referenced in the project.
  - Add a migration and update DB:

```powershell
dotnet ef migrations add AddMyChange; dotnet ef database update
```

- Using EF Core Power Tools (Visual Studio extension) to regenerate code:
  - Open the solution in Visual Studio, right-click the project -> "EF Core Power Tools" -> "Reverse Engineer".
  - Select the database and the objects to scaffold. Power Tools will produce `Data/Context.cs` and `Models/*` with the `<auto-generated>` header (this repo's current pattern).
  - After regeneration, verify constructors and DI usage in `Pages/*` because class/namespace names may change.

- Notes and gotchas:
  - This repo currently includes generated files (look for `<auto-generated>` header). Prefer regenerating rather than hand-editing those files when schema changes are required.
  - If you choose migrations, commit the migration files and update `readme.md` with the chosen DB instance name so others can run `dotnet ef database update` locally.
  - If you change namespaces or class names in generated code, update usages in Razor Pages (constructor signatures) and DI registration if necessary.

